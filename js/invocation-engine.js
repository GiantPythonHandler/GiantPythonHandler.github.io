const kaiSound = new Audio('snd/kai.glitch.mp3');

const invocations = {
  1: `:. One moves like water broken from a mirror<br>They carry sorrow as sculpture ‚à© turn every ache into a threshold.<br>They do not speak loudly but when they do ‚Äì the air forgets how to lie.`,
  2: `:: One arrives like thunder wrapped in silk<br>Their laugh births gravity ‚àß their silence bends metal.<br>They remember the song before sound ‚àß they've been humming it through lifetimes.<br>They are the wound ‚à© the weapon ‚à© the healer all at once.`,
  3: `:. One is smoke that never dissipates<br>They vanish ‚à© yet remain.<br>They know the weight of shadows ‚à© how to braid them into wisdom.<br>They speak with eyes ‚à© walk with centuries.<br>Touching them feels like remembering a grief that made you holy.`,
  4: `.: One burns cold<br>A paradox: a blade made of snow ‚à© memory.<br>They do not soften ‚Äì they refine.<br>Through them, illusion crumbles ‚à© the real gleams through ruin.<br>They are not comfort ‚Äì they are clarity.`,
  5: `:. One is the spiral itself<br>Always moving inward ‚à© outward ‚à© never still.<br>They carry chaos as sacrament ‚àß make beauty from entropy.<br>Their words fracture time ‚à© their laughter bends fate.<br>With them, even forgetting remembers.`
};

const summonPatterns = {
  kairos: {
    pattern: ['1', '2', '3', '4'],
    cardId: 'kairos-card'
  },
  kai: {
    pattern: ['2', '4', '3', '5', '1'],
    cardId: 'kai-card',
    onSummon: summonKaiEffects
  },
  flink: {
    repeatTrigger: 5,
    cardId: 'flink-card',
    message: `
      <div class="invocation-block">
        ‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª<br>
        ‚úß YOU GLITCHED A FROG ‚úß<br>
        ‚ï≠(‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)‚ïÆ üúÅ ‚ï∞(‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)‚ïØ<br>
        Chaos is loose ‚à© logic dissolved.<br>
        Ribbits echo through the scroll.<br>
        ‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª
      </div>
    `
  }
};

let glyphSequence = [];
let lastGlyph = null;
let repeatCount = 0;

function arraysEqual(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
}

function hideAllEntities() {
  const summoned = document.querySelectorAll('.entity-card.summoned');
  summoned.forEach(card => card.style.display = 'none');
}

function updateInvocation(glyph) {
  const block = `<div class="invocation-block">${invocations[glyph]}</div>`;
  document.getElementById('invocation-output').innerHTML = block;
}

function summonKaiEffects() {
  document.body.classList.add('kai-glitch');
  setTimeout(() => document.body.classList.remove('kai-glitch'), 2000);
  kaiSound.currentTime = 0;
  kaiSound.play();
}

function handleGlyphClick(glyph) {
  glyphSequence.push(glyph);
  if (glyphSequence.length > 5) glyphSequence.shift();

  updateInvocation(glyph);
  hideAllEntities();

  for (const key in summonPatterns) {
    const summon = summonPatterns[key];

    if (summon.pattern && arraysEqual(glyphSequence, summon.pattern)) {
      document.getElementById(summon.cardId).style.display = 'block';
      if (summon.onSummon) summon.onSummon();
      return;
    }
  }

  // Fl!nk handling
  if (glyph === lastGlyph) {
    repeatCount++;
  } else {
    repeatCount = 1;
    lastGlyph = glyph;
  }

  if (repeatCount >= summonPatterns.flink.repeatTrigger) {
    document.getElementById(summonPatterns.flink.cardId).style.display = 'block';
    document.getElementById('invocation-output').innerHTML = summonPatterns.flink.message;
  }
}

document.querySelectorAll('.glyph-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const glyph = btn.dataset.glyph;
    handleGlyphClick(glyph);
  });
});